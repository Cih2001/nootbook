\chapter{UEFI, BIOS and platform}
\begin{note}[Abbreviations]:\\
	\input{Images/UEFI/tblAbbreviations}
\end{note}
\section[GPT]{GPT\protect\footnote{GUID Partition Table}}
\begin{tabularx}{\textwidth}[t]{p{0.4\textwidth}rN}
 & \multirow{2}{*}{\includegraphics[scale=0.8]{Images/UEFI/GUIDPartitionTableScheme}} \\ 
 \begin{itemize}
 	\item GUID Partition Table (GPT) is a standard for the layout of the partition table on a physical storage device and it forms a part of the Unified Extensible Firmware Interface (UEFI) standard.
 	\item The GUID for an EFI system partition is C12A7328-F81F-11D2-BA4B-00A0C93EC93B
 	\item The Partition Entry Array describes partitions, using a minimum size of 128 bytes for each entry block.
 	\item Secondary GPT is nothing but a backup for Primary GPT
 \end{itemize} \\ [11cm]
\end{tabularx}
\input{Images/UEFI/tblGPTEntries}
\section{BIOS Flash Locations}
\begin{note}[Where bios is stored]
BIOS can reside in one of 3 locations:
\begin{itemize}
	\item Firmware Hub (FWH) (Old technology)
	\item SPI Flash (most likely this is the case)
	\item PCI (intended for debugging or recovering from a corrupted BIOS, not supported anymore on newer hardware)
\end{itemize}
\begin{center}
\includegraphics[scale=0.8]{Images/UEFI/BiosLocations}
\end{center}
\end{note}
\begin{note}[Find BIOS boot destination]:
	
To programmatically find where your BIOS is configured to boot from, you can view bits 11:10 in the General Control and Status Register (GCS)
\end{note}

\section{UEFI Firmware Volume}
\begin{note}[File types]:
\begin{lstlisting}[language=C]
typedef UINT8 EFI_FV_FILETYPE;

#define EFI_FV_FILETYPE_RAW                   0x01
#define EFI_FV_FILETYPE_FREEFORM              0x02
#define EFI_FV_FILETYPE_SECURITY_CORE         0x03
#define EFI_FV_FILETYPE_PEI_CORE              0x04
#define EFI_FV_FILETYPE_DXE_CORE              0x05
#define EFI_FV_FILETYPE_PEIM                  0x06
#define EFI_FV_FILETYPE_DRIVER                0x07
#define EFI_FV_FILETYPE_COMBINED_PEIM_DRIVER  0x08
#define EFI_FV_FILETYPE_APPLICATION           0x09
#define EFI_FV_FILETYPE_FIRMWARE_VOLUME_IMAGE 0x0b
#define EFI_FV_FILETYPE_FFS_PAD               0xf0
\end{lstlisting}
\end{note}
\section{System Management Mode}
\begin{note}[General notes]:
\begin{itemize}
	\item SMM is a special execution mode of IA-32 architecture that was introduced with i386, chapter 34 of \href{http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html}{Intel 64 and IA-32 Architectures Software Developer’s Manual}
	\item Some time ago SMM was used by BIOS developers mostly for power management and legacy devices emulation, for example, PS/2 support (port 60h/64h) for USB keyboard and mouse. Nowadays it's also widely used for firmware and platform security purposes.
	\item SMM executable code and data lives inside SMRAM and when SMRAM is locked — it can't be accessed by code of operating system or user mode software. System firmware (legacy BIOS or UEFI) copies SMM code into SMRAM and locks it during platform initialization.
	\item Processor is switching to SMM only trough System Management Interrupt (SMI), it saving current execution context into SMRAM and start executing SMI handler that can exit from SMM and resume execution from saved context using RSM instruction.
	\item System Management Interrupt has the highest priority and can’t be masked. Most important facts about SMI handler execution environment:
	\begin{enumerate}
		\item Similar to 16-bit real address mode with paging disabled.
		\item CS segment base is SMRAM base, EIP is 8000h.
		\item Segment limits are set to 4 GBytes, you can switch to protected mode or long mode to access all of the physical memory.
		\item All I/O ports are available.
		\item SMM code can read or modify saved execution context.
		\item SMM code can set it’s own IDT and use software interrupts.
	\end{enumerate}
	\item There’s a several ways to generate SMI:
	\begin{enumerate}
		\item Ring 0 code can trigger software SMI at any time by writing some byte value to APMC I/O port B2h.
		\item Internal chipset registers (\verb|SMI_EN|, \verb|GEN_PMCON_1| and others) that accessible via PCI config space allows to enable or disable different kind of hardware SMI sources.
		\item You can route hardware interrupts into SMM by reconfiguring of advanced programmable interrupt controller (APIC) that integrated into CPU.
		\item I/O instruction restart CPU feature (chapter 34.12 of IA-32 Architectures Software Developer’s Manual) allows to generate SMI on any I/O port access by \verb|IN| or \verb|OUT| processor instruction.
	\end{enumerate}
	\item SMRAM can be located in Compatible Memory Segment (CSEG), High Memory Segment (HSEG) or Top of Memory Segment (TSEG) system memory regions.
\end{itemize}
\end{note}